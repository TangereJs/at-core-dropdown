<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">

<dom-module id="at-core-dropdown">
  <template>
    <style include="at-form-common"></style>
    <style>
      .container {
        display: block;
        margin: 0;
        padding: 0;
        border: none;
        position: absolute;
        overflow: visible;
        height: 0;
        width: 0;
        visibility: hidden;
        z-index: -1;
      }

      .container.is-visible,
      .container.is-animating {
        z-index: 999;
        visibility: visible;
      }

      .outline {
        display: block;
        background: white;
        margin: 0;
        padding: 0;
        border: none;
        border-radius: 2px;
        position: absolute;
        top: 0;
        left: 0;
        overflow: hidden;
        opacity: 0;
        -webkit-transform: scale(0);
        transform: scale(0);
        -webkit-transform-origin: 0 0;
        transform-origin: 0 0;
        box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);
        will-change: transform;
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: -1;
      }

      .container.is-visible .outline {
        opacity: 1;
        -webkit-transform: scale(1);
        transform: scale(1);
        z-index: 999;
      }

      .outline.position--bottom-right {
        -webkit-transform-origin: 100% 0;
        transform-origin: 100% 0;
      }

      .outline.position--top-left {
        -webkit-transform-origin: 0 100%;
        transform-origin: 0 100%;
      }

      .outline.position--top-right {
        -webkit-transform-origin: 100% 100%;
        transform-origin: 100% 100%;
      }

      .content {
        position: absolute;
        list-style: none;
        top: 0;
        left: 0;
        height: auto;
        width: auto;
        min-width: 124px;
        padding: 8px 0;
        margin: 0;
        opacity: 0;
        /*clip: rect(0 0 0 0);*/
        z-index: -1;
        @apply(--at-picker-background);
      }

      .content.hidden {
        display: none;
      }

      .container.is-visible .content {
        opacity: 1;
        z-index: 999;
      }

      .content.is-animating {
        transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        /*, clip 0.3s cubic-bezier(0.4, 0, 0.2, 1);*/
      }

      .content.position--bottom-right {
        left: auto;
        right: 0;
      }

      .content.position--top-left {
        top: auto;
        bottom: 0;
      }

      .content.position--top-right {
        top: auto;
        left: auto;
        bottom: 0;
        right: 0;
      }

      .content.position--unaligned {
        top: auto;
        left: auto;
      }

      #mask {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: transparent;
        opacity: 0.3;
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
        z-index: 2;
        -webkit-transition: opacity 0.3s ease-in-out;
        -moz-transition: opacity 0.3s ease-in-out;
        -ms-transition: opacity 0.3s ease-in-out;
        -o-transition: opacity 0.3s ease-in-out;
        transition: opacity 0.3s ease-in-out;
      }

      #mask.hidden {
        display: none;
      }
    </style>
    <div id="container" class="container">
      <div id="mask" class="hidden" on-tap="_maskOnTap"></div>
      <div id="outline" class="outline position--bottom-left"></div>
      <div id="atCoreDropdownContent" class="content hidden position--bottom-left">
        <content id="insertPoint"></content>
      </div>
    </div>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-core-dropdown',
      hostAttributes: {
        tabindex: -1
      },
      properties: {
        position: {
          type: String,
          value: "bottomLeft",
          observer: 'positionChanged',
          xtype: "enum",
          xvaluelist: [{
            title: "Top Left",
            value: "topLeft"
          }, {
            title: "Top Right",
            value: "topRight"
          }, {
            title: "Bottom Left",
            value: "bottomLeft"
          }, {
            title: "Bottom Right",
            value: "bottomRight"
          }]
        }
      },
      ready: function() {
        this.Constant_ = {
          // Total duration of the menu animation.
          TRANSITION_DURATION_SECONDS: 0.3,
          // The fraction of the total duration we want to use for menu item animations.
          TRANSITION_DURATION_FRACTION: 0.8,
          // How long the menu stays open after choosing an option (so the user can see
          // the ripple).
          CLOSE_TIMEOUT: 150
        };

        this.CssClasses_ = {
          CONTAINER: 'container',
          OUTLINE: 'outline',
          ITEM: 'item',
          // Statuses
          IS_UPGRADED: 'is-upgraded',
          IS_VISIBLE: 'is-visible',
          IS_ANIMATING: 'is-animating',
          // Alignment options
          BOTTOM_LEFT: 'position--bottom-left', // This is the default.
          BOTTOM_RIGHT: 'position--bottom-right',
          TOP_LEFT: 'position--top-left',
          TOP_RIGHT: 'position--top-right',
          UNALIGNED: 'position--unaligned'
        };
      },
      _isPositionValueValid: function(value) {
        var list = this.properties.position.xvaluelist;
        var found = false;
        var listLength = list.length;
        var listItem;
        for (var i = 0; i < listLength; i++) {
          listItem = list[i];
          if (listItem.value === value) {
            found = listItem;
            break;
          }
        }
        var result = found !== false;
        return result;
      },
      isOpen: function() {
        return this._isOpen;
      },
      positionChanged: function(newValue, oldValue) {
        if (this._isPositionValueValid(newValue)) {
          var content = this.$.atCoreDropdownContent;
          var outline = this.$.outline;
          // update css class
          var classPrefix = 'position--';
          var mode = 'bottom-left';
          var className = classPrefix + mode;
          if (oldValue) {
            mode = Polymer.CaseMap.camelToDashCase(oldValue);
            className = classPrefix + mode;
          }
          Polymer.dom(content).classList.remove(className);
          Polymer.dom(outline).classList.remove(className);

          if (newValue) {
            mode = Polymer.CaseMap.camelToDashCase(newValue)
            className = classPrefix + mode;
          }
          Polymer.dom(content).classList.add(className);
          Polymer.dom(outline).classList.add(className);
        }
      },
      toggle: function(relativeTo, evt) {
        this._updateDropdownPosition(relativeTo);

        var container = this.$.container;
        if (container.classList.contains(this.CssClasses_.IS_VISIBLE)) {
          this.hide();
        } else {
          this.show(evt);
        }
      },
      _updateDropdownPosition: function(relativeTo) {
        var rect = relativeTo.getBoundingClientRect();
        var forRect = relativeTo.parentElement.getBoundingClientRect();
        var content = this.$.atCoreDropdownContent;
        var container = this.$.container;
        if (content.classList.contains(this.CssClasses_.UNALIGNED)) {
          // Do not position the menu automatically. Requires the developer to
          // manually specify position.
        } else if (content.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
          // Position below the "for" element, aligned to its right.
          container.style.right = (forRect.right - rect.right) + 'px';
          // container.style.top = relativeTo.offsetTop + relativeTo.offsetHeight + 'px';
          container.style.bottom = '';
        } else if (content.classList.contains(this.CssClasses_.TOP_LEFT)) {
          // Position above the "for" element, aligned to its left.
          container.style.left = relativeTo.offsetLeft + 'px';
          container.style.bottom = (forRect.bottom - rect.top) + 'px';
        } else if (content.classList.contains(this.CssClasses_.TOP_RIGHT)) {
          // Position above the "for" element, aligned to its right.
          container.style.right = (forRect.right - rect.right) + 'px';
          container.style.bottom = (forRect.bottom - rect.top) + 'px';
        } else {
          // Default: position below the "for" element, aligned to its left.
          container.style.left = relativeTo.offsetLeft + 'px';
          // container.style.top = relativeTo.offsetTop + relativeTo.offsetHeight + 'px';
          container.style.bottom = '';
        }
      },
      show: function(evt, relativeTo) {
        var content = this.$.atCoreDropdownContent;
        var container = this.$.container;
        var outline = this.$.outline;

        this.toggleClass('hidden', false, content);

        // Measure the inner element.
        var height = content.getBoundingClientRect().height;
        var width = content.getBoundingClientRect().width;

        if (relativeTo) {
          this._updateDropdownPosition(relativeTo);
        }

        // Apply the inner element's size to the container and outline.
        container.style.width = width + 'px';
        container.style.height = height + 'px';
        outline.style.width = width + 'px';
        outline.style.height = height + 'px';

        var transitionDuration = this.Constant_.TRANSITION_DURATION_SECONDS * this.Constant_.TRANSITION_DURATION_FRACTION;

        // Apply the initial clip to the text before we start animating.
        // this.applyClip_(height, width);

        // Turn on animation, and apply the final clip.
        // Also make it visible. This triggers the transitions.
        this._requestAnimationFrameEnded = false;
        requestAnimationFrame(function() {
          Polymer.dom(content).classList.add(this.CssClasses_.IS_ANIMATING);
          // content.style.clip = 'rect(0 ' + width + 'px ' + height + 'px 0)';
          Polymer.dom(container).classList.add(this.CssClasses_.IS_VISIBLE);
          this._requestAnimationFrameEnded = true;
        }.bind(this));

        // Clean up after the animation is complete.
        this.addAnimationEndListener_();

        var mask = this.$.mask;
        this.toggleClass('hidden', false, mask);


        this._isOpen = true;
        // this.focus();
      },
      _maskOnTap: function(event) {
        var mask = this.$.mask;

        this.toggleClass('hidden', true, mask);
        var content = this.$.atCoreDropdownContent;
        this.toggleClass('hidden', true, content);
        this.hide();
      },
      hide: function() {
        // Measure the inner element.
        var rect = this.$.atCoreDropdownContent.getBoundingClientRect();
        var height = rect.height;
        var width = rect.width;
        var content = this.$.atCoreDropdownContent;
        var container = this.$.container;
        var cssClasses = this.CssClasses_;
        var self = this;
        if (this._requestAnimationFrameEnded) {
          // Turn on animation, and apply the final clip. Also make invisible.
          // This triggers the transitions.
          Polymer.dom(content).classList.add(cssClasses.IS_ANIMATING);
          // this.applyClip_(height, width);
          Polymer.dom(container).classList.remove(cssClasses.IS_VISIBLE);
        } else {
          requestAnimationFrame(function() {
            Polymer.dom(content).classList.add(cssClasses.IS_ANIMATING);
            // self.applyClip_(height, width);
            Polymer.dom(container).classList.remove(cssClasses.IS_VISIBLE);
          });
        }

        // Clean up after the animation is complete.
        this.addAnimationEndListener_();

        this._isOpen = false;
      },
      applyClip_: function(height, width) {
        var content = this.$.atCoreDropdownContent;
        if (content.classList.contains(this.CssClasses_.UNALIGNED)) {
          // Do not clip.
          content.style.clip = '';
        } else if (
          content.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
          // Clip to the top right corner of the menu.
          content.style.clip = 'rect(0 ' + width + 'px 0 ' + width + 'px)';
        } else if (content.classList.contains(this.CssClasses_.TOP_LEFT)) {
          // Clip to the bottom left corner of the menu.
          content.style.clip = 'rect(' + height + 'px 0 ' + height + 'px 0)';
        } else if (content.classList.contains(this.CssClasses_.TOP_RIGHT)) {
          // Clip to the bottom right corner of the menu.
          content.style.clip = 'rect(' + height + 'px ' + width + 'px ' + height + 'px ' + width + 'px)';
        } else {
          // Default: do not clip (same as clipping to the top left corner).
          content.style.clip = '';
        }
      },
      removeAnimationEndListener_: function(evt) {
        Polymer.dom(evt.target).classList.remove(this.CssClasses_.IS_ANIMATING);
      },
      addAnimationEndListener_: function() {
        var content = this.$.atCoreDropdownContent;
        content.addEventListener('transitionend', this.removeAnimationEndListener_.bind(this));
        content.addEventListener('webkitTransitionEnd', this.removeAnimationEndListener_.bind(this));
      }
    });
  </script>
</dom-module>
